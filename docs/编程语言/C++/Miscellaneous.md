# Miscellaneous
!!!abstract
    C++就像编程语言届的原神，C++新的特性非常非常多，你可以在现在的C++看到很多编程语言的影子。比如容器元素的遍历至少有三种不同的写法，其中range for loop就像极了Python
## C++ 标准
每三年一修，下面的代码能够输出C++标准的版本，每个版本都会被塞进去一堆新特性~，最新的是C++23。
```C++
#include <iostream>
int main(){
    std::cout << __cplusplus << std::endl;
    return 0;
}
```
## declaration and definition
Every  name is introduced by declaration.
声明只是引入了一个名字，定义是是要有实体，定义完就可以使用了。
C++ 允许一个名字被多次声明，但不能多次定义。
### 声明 (Declaration)
- **声明**是告诉编译器某个变量或函数的存在和类型，但并不提供其具体的实现。
- 声明的目的是使编译器知道某个符号的名字和它的类型，以便在使用它时不会出现错误。
- 声明通常放在头文件 (`.h` 文件) 中。
- **示例**：
  ```cpp
  extern int globalVariable;  // 变量声明
  void function();            // 函数声明
  ```

### 定义 (Definition)
- **定义**是提供变量或函数的具体实现或存储空间。定义不仅告诉编译器某个符号的名字和类型，还告诉它如何实际存储或实现该符号。
- 定义通常出现在源文件 (`.cpp` 文件) 中。
- **示例**：
  ```cpp
  int globalVariable = 10;    // 变量定义
  void function() {           // 函数定义
      // 函数体
  }
  ```

通常情况下，声明会在头文件中出现，而定义会在源文件中出现。这样做的目的是为了将接口和实现分开，使代码更加模块化和易于维护。

## Left Value and Right Value
表达式可能产生值，并可能导致副作用
事实上，每个表达式都有两种性质
* type：就是本身的类型
* value category：分为左值和右值
  * 左值refer to 一个对象的表达式
  * 右值是不与对象关联的表达式

在C++中，左值（lvalue）和右值（rvalue）是用来描述表达式的不同类型的值。这两者在表达式的使用和赋值操作中扮演着不同的角色。以下是它们的主要区别：

### 左值（lvalue）

- **定义**: 左值（locator value）表示对象的地址，通常指向内存中的某个位置。你可以将它看作是一个可以出现在赋值语句左边的值。
- **特征**: 左值可以出现在赋值语句的左边，比如 `x = 5` 中的 `x` 是一个左值。
- **用途**: 左值可以绑定到引用（左值引用），并且可以通过指针访问其地址。
- **示例**: 
  ```cpp
  int x = 10; // x 是左值
  x = 20;     // 赋值语句中的 x 是左值
  ```

### 右值（rvalue）

- **定义**: 右值（read value）表示一个没有持久存储地址的值。它通常是一个临时的、不可修改的值，常用于表达式的右边。
- **特征**: 右值出现在赋值语句的右边，例如 `x = 5` 中的 `5` 是一个右值。
- **用途**: 右值不能绑定到左值引用，但可以绑定到右值引用（在C++11及以后的版本中）。右值通常用于移动语义和完美转发。
- **示例**: 
  ```cpp
  int y = 5;  // 5 是右值
  ```

### 右值引用

在C++11及以后版本中，右值引用（`T&&`）允许你对右值进行操作，比如在移动语义中移动资源而不是复制。这样可以提高程序的效率。

### 左值引用与右值引用

- **左值引用**: 用于绑定左值，声明为 `T&`。
- **右值引用**: 用于绑定右值，声明为 `T&&`。

### 例子

```cpp
void func(int& x) { /*...*/ } // 接受左值引用
void func(int&& x) { /*...*/ } // 接受右值引用

int main() {
    int a = 10;
    func(a);       // 调用接受左值引用的函数
    func(20);      // 调用接受右值引用的函数
}
```

了解左值和右值的区别对于掌握C++的内存管理、资源优化和函数重载非常重要。

## About Reference
相当于给对象起了别称，引用可以看做是C++封装的指针，引用必须被初始化，以下代码是<font color = red>非法的</font>
``` C++
int &refVal2;
```

## About const
!!!warning
    这个问题相当之复杂（ 但是还是比较值得弄清楚，并且根据C++的最佳实践原则，很多时候都最好要把const加上
* 默认状态下，const对象仅在文件内有效：原因是编译器会做常量替换，所以编译器需要知道初始值，解决方法是加extern关键字
* 非常量引用不能指向一个常量对象，，以下代码是<font color = red>非法的</font>
``` C++
const int c = 1024;
int & p = c;
```
* 可以引用常量对象，简称常量引用，但是不能直接引用常量（
* 初始化常量引用可以用任何表达式作为初始值，只要该表达式的结果能转换成引用的类型即可
* 一个常量引用被绑定到另一种类型上时实际上会绑定到一个类型匹配的临时对象上，但由于这种情况不符合预期编译器依旧会判定为非法
* const 可以绑定非const的对象，但是不能通过const引用来修改对象的值
* 想存放常量对象的地址也只有用常量指针，常量指针必须初始化，但是常量指针也可以指向可变对象，一般用顶层表示指针本身是常量，底层表示指针所指对象是常量
* 这个问题比较复杂，和关键字的结合性有关，示例：
``` c++
int i = 0;
int *const p1 = &i; //top,从右向左阅读，p1一直指向i的首地址
const int ci = 42; //top
const int *p2 = &ci; //low，p2指向常量对象，但是可以更改具体指向哪个常量对象
const int *const p3 = p2; //靠右的是top，靠左的是low
const int &r = ci; // 用于声明引用的const都是low
```
* 在拷贝时顶层const几乎不受影响，但是拷入和拷出对象必须具有相同的底层const资格。一般来说非常量可以转化成常量，反之则不行。
* ```const int sz = get_size();```不算常量表达式
* C++11 新标准规定，允许将变量声明为consexpr类型以便编译器检验变量的值是否是一个常量表达式

## optional
`<optional>` 是 C++17 引入的一个库，它提供了一种用于表示可能缺失值的工具。使用 `std::optional`，你可以表示一个值要么存在（即有一个有效值），要么不存在（即没有值）。这在处理可能的空值时特别有用，比如在返回函数的值时，表示成功与否的情况。

Example
``` C++
#include <iostream>
#include <optional>

std::optional<int> getValue(bool shouldReturnValue) {
    if (shouldReturnValue) {
        return 42;
    } else {
        return std::nullopt; // 返回一个空的 optional
    }
}

int main() {
    auto value = getValue(true);
    if (value) {
        std::cout << "Value: " << *value << std::endl; // 使用 * 解引用
    } else {
        std::cout << "No value" << std::endl;
    }
    return 0;
}
```
## cast conversion
C++ 中提供了几种类型的类型转换

### 1. **静态转换 (`static_cast`)**
   - **用途：** 这是最常见的类型转换，用于那些定义明确且不需要运行时检查的转换。主要用于：
     - 数值类型之间的转换（例如，`int` 到 `float`）。
     - 在继承关系中指针的转换（例如，向上转换和向下转换，但向下转换要小心使用）。
     - 将 `void*` 转换为特定的指针类型。

### 2. **动态转换 (`dynamic_cast`)**
   - **用途：** 用于在继承层次结构中安全地向下转换指针（或引用）。它会在运行时检查转换是否有效，如果转换失败，则返回 `nullptr`（对于指针）。要求基类至少有一个虚函数。

### 3. **常量转换 (`const_cast`)**
   - **用途：** 用于添加或移除变量的 `const` 限定符。这是唯一可以修改 `const` 属性的转换类型。

### 4. **重解释转换 (`reinterpret_cast`)**
   - **用途：** 这种转换用于低级别的位模式重新解释。它可以将一种类型转换为任意其他相同大小的类型，例如将指针转换为整数类型或反过来。使用时要非常谨慎，因为这可能导致不安全的代码。

### 5. **C 风格转换**
   - **用途：** C 风格的转换是最通用也是最不安全的。它会依次尝试执行 `static_cast`、`const_cast` 和 `reinterpret_cast`，直到成功。这使得跟踪执行的转换类型变得困难，从而降低了代码的安全性。所以不要用这种转换方法。

### **何时使用每种转换**
- **`static_cast`：** 当你确定转换是安全且定义明确时使用。
- **`dynamic_cast`：** 在多态情况下使用，当你需要安全地向下转换时。
- **`const_cast`：** 仅在需要修改变量的 `const` 属性时使用。
- **`reinterpret_cast`：** 在需要执行低级别的数据重新解释时谨慎使用。

## Parameter Pack
`Parameter pack` 是 C++11 引入的一个功能，用于在模板中表示任意数量的模板参数。它可以用来处理不定长的参数列表，从而使模板更加灵活和通用。

在 C++ 中，`Parameter pack` 通常用于以下两种情况：

1. **模板参数包（Template Parameter Pack）**：允许模板接受任意数量的类型参数。例如：

   ```cpp
   template<typename... Args>
   void func(Args... args) {
       // 在这里，args 是一个参数包，可以包含任意数量的参数
   }
   ```

2. **函数参数包（Function Parameter Pack）**：允许函数接受任意数量的函数参数。例如：

   ```cpp
   template<typename... Args>
   void func(Args... args) {
       // 处理参数包 args
   }
   ```

   这里 `args...` 表示函数参数包，它可以捕获传递给函数的任意数量的参数。

要展开和使用参数包，通常会结合递归或通过折叠表达式（C++17 引入）来简化操作。例如：

```cpp
template<typename... Args>
void print(Args... args) {
    (std::cout << ... << args) << std::endl; // 使用折叠表达式打印所有参数
}
```